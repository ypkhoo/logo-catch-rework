<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, 
    user-scalable=no, initial-scale=1, maximum-scale=1, user-scalable=0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <style type="text/css">
        body {
            margin: 0;
            padding: 0;
            background: #000;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: #fff;
        }
    </style>

</head>

<body>
    <canvas></canvas>
    <script>

        // http://paulirish.com/2011/requestanimationframe-for-smart-animating
        // shim layer with setTimeout fallback
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

        // namespace our game
        var LC = {

            // set up some inital values
            WIDTH: 320,
            HEIGHT: 480,
            scale: 1,
            // the position of the canvas
            // in relation to the screen
            offset: { top: 0, left: 0 },
            // store all bubble, touches, particles etc
            entities: [],
            // the amount of game ticks until
            // we spawn a bubble
            nextBubble: 100,
            // for tracking player's progress
            score: {
                taps: 0,
                hit: 0,
                escaped: 0,
                accuracy: 0
            },
            // we'll set the rest of these
            // in the init function
            RATIO: null,
            currentWidth: null,
            currentHeight: null,
            canvas: null,
            ctx: null,
            ua: null,
            android: null,
            ios: null,

            init: function () {

                // the proportion of width to height
                LC.RATIO = LC.WIDTH / LC.HEIGHT;
                // these will change when the screen is resize
                LC.currentWidth = LC.WIDTH;
                LC.currentHeight = LC.HEIGHT;
                // this is our canvas element
                LC.canvas = document.getElementsByTagName('canvas')[0];
                // it's important to set this
                // otherwise the browser will
                // default to 320x200
                LC.canvas.width = LC.WIDTH;
                LC.canvas.height = LC.HEIGHT;
                // the canvas context allows us to 
                // interact with the canvas api
                LC.ctx = LC.canvas.getContext('2d');
                // we need to sniff out android & ios
                // so we can hide the address bar in
                // our resize function
                LC.ua = navigator.userAgent.toLowerCase();
                LC.android = LC.ua.indexOf('android') > -1 ? true : false;
                LC.ios = (LC.ua.indexOf('iphone') > -1 || LC.ua.indexOf('ipad') > -1) ? true : false;

                // listen for clicks
                window.addEventListener('click', function (e) {
                    e.preventDefault();
                    LC.Input.set(e);
                }, false);

                // listen for touches
                window.addEventListener('touchstart', function (e) {
                    e.preventDefault();
                    // the event object has an array
                    // called touches, we just want
                    // the first touch
                    LC.Input.set(e.touches[0]);
                }, false);
                window.addEventListener('touchmove', function (e) {
                    // we're not interested in this
                    // but prevent default behaviour
                    // so the screen doesn't scroll
                    // or zoom
                    e.preventDefault();
                }, false);
                window.addEventListener('touchend', function (e) {
                    // as above
                    e.preventDefault();
                }, false);

                // we're ready to resize
                LC.resize();

                LC.loop();

            },


            resize: function () {

                LC.currentHeight = window.innerHeight;
                // resize the width in proportion
                // to the new height
                LC.currentWidth = LC.currentHeight * LC.RATIO;

                // this will create some extra space on the
                // page, allowing us to scroll pass
                // the address bar, and thus hide it.
                if (LC.android || LC.ios) {
                    document.body.style.height = (window.innerHeight + 50) + 'px';
                }

                // set the new canvas style width & height
                // note: our canvas is still 320x480 but
                // we're essentially scaling it with CSS
                LC.canvas.style.width = LC.currentWidth + 'px';
                LC.canvas.style.height = LC.currentHeight + 'px';

                // the amount by which the css resized canvas
                // is different to the actual (480x320) size.
                LC.scale = LC.currentWidth / LC.WIDTH;
                // position of canvas in relation to
                // the screen
                LC.offset.top = LC.canvas.offsetTop;
                LC.offset.left = LC.canvas.offsetLeft;

                // we use a timeout here as some mobile
                // browsers won't scroll if there is not
                // a small delay
                window.setTimeout(function () {
                    window.scrollTo(0, 1);
                }, 1);
            },

            // this is where all entities will be moved
            // and checked for collisions etc
            update: function () {
                var i,
                    checkCollision = false; // we only need to check for a collision
                // if the user tapped on this game tick


                // decrease our nextBubble counter
                LC.nextBubble -= 1;
                // if the counter is less than zero
                if (LC.nextBubble < 0) {
                    // put a new instance of bubble into our entities array
                    LC.entities.push(new LC.Bubble());
                    // reset the counter with a random value
                    LC.nextBubble = (Math.random() * 100) + 100;
                }

                // spawn a new instance of Touch
                // if the user has tapped the screen
                if (LC.Input.tapped) {
                    // keep track of taps; needed to 
                    // calculate accuracy
                    LC.score.taps += 1;
                    // add a new touch
                    LC.entities.push(new LC.Touch(LC.Input.x, LC.Input.y));
                    // set tapped back to false
                    // to avoid spawning a new touch
                    // in the next cycle
                    LC.Input.tapped = false;
                    checkCollision = true;
                }

                // cycle through all entities and update as necessary
                for (i = 0; i < LC.entities.length; i += 1) {
                    LC.entities[i].update();

                    if (LC.entities[i].type === 'bubble' && checkCollision) {
                        hit = LC.collides(LC.entities[i],
                            { x: LC.Input.x, y: LC.Input.y, r: 7 });
                        if (hit) {
                            // spawn an exposion
                            for (var n = 0; n < 5; n += 1) {
                                LC.entities.push(new LC.Particle(
                                    LC.entities[i].x,
                                    LC.entities[i].y,
                                    2,
                                    // random opacity to spice it up a bit
                                    'rgba(255,255,255,' + Math.random() * 1 + ')'
                                ));
                            }
                            LC.score.hit += 1;
                        }

                        LC.entities[i].remove = hit;
                    }

                    // delete from array if remove property
                    // flag is set to true
                    if (LC.entities[i].remove) {
                        LC.entities.splice(i, 1);
                    }
                }
                
                // calculate accuracy
                LC.score.accuracy = (LC.score.hit / LC.score.taps) * 100;
                LC.score.accuracy = isNaN(LC.score.accuracy) ?
                    0 :
                    ~~(LC.score.accuracy); // a handy way to round floats

            },


            // this is where we draw all the entities
            render: function () {

                var i;


                LC.Draw.rect(0, 0, LC.WIDTH, LC.HEIGHT, '#036');

                // display snazzy wave effect
                for (i = 0; i < LC.wave.total; i++) {

                    LC.Draw.circle(
                        LC.wave.x + LC.wave.offset + (i * LC.wave.r),
                        LC.wave.y,
                        LC.wave.r,
                        '#fff');
                }

                // cycle through all entities and render to canvas
                for (i = 0; i < LC.entities.length; i += 1) {
                    LC.entities[i].render();
                }

                // display scores
                LC.Draw.text('SCORE: ' + LC.score.hit, 20, 30, 14, '#fff');
                LC.Draw.text('TIME: ' + '30', 240, 30, 14, '#fff'); 
                LC.Draw.text('Escaped: ' + LC.score.escaped, 20, 50, 14, '#fff');
                LC.Draw.text('Accuracy: ' + LC.score.accuracy + '%', 20, 70, 14, '#fff');

            },


            // the actual loop
            // requests animation frame
            // then proceeds to update
            // and render
            loop: function () {

                requestAnimFrame(LC.loop);

                LC.update();
                LC.render();
            }


        };

        // checks if two entties are touching
        LC.collides = function (a, b) {

            var distance_squared = (((a.x - b.x) * (a.x - b.x)) +
                ((a.y - b.y) * (a.y - b.y)));

            var radii_squared = (a.r + b.r) * (a.r + b.r);

            if (distance_squared < radii_squared) {
                return true;
            } else {
                return false;
            }
        };


        // abstracts various canvas operations into
        // standalone functions
        LC.Draw = {

            clear: function () {
                LC.ctx.clearRect(0, 0, LC.WIDTH, LC.HEIGHT);
            },


            rect: function (x, y, w, h, col) {
                LC.ctx.fillStyle = col;
                LC.ctx.fillRect(x, y, w, h);
            },

            circle: function (x, y, r, col) {
                LC.ctx.fillStyle = col;
                LC.ctx.beginPath();
                LC.ctx.arc(x + 5, y + 5, r, 0, Math.PI * 2, true);
                LC.ctx.closePath();
                LC.ctx.fill();
            }, 

            logo: function (x,y) {
                var img = new Image(); 
                img.src = './assets/1x/2.healthyfoods-2.png'; 
                LC.ctx.drawImage(img, x, y); 
            }, 

            text: function (string, x, y, size, col) {
                LC.ctx.font = 'bold ' + size + 'px Monospace';
                LC.ctx.fillStyle = col;
                LC.ctx.fillText(string, x, y);
            }

        };



        LC.Input = {

            x: 0,
            y: 0,
            tapped: false,

            set: function (data) {
                this.x = (data.pageX - LC.offset.left) / LC.scale;
                this.y = (data.pageY - LC.offset.top) / LC.scale;
                this.tapped = true;

            }

        };

        LC.Touch = function (x, y) {

            this.type = 'touch';    // we'll need this later
            this.x = x;             // the x coordinate
            this.y = y;             // the y coordinate
            this.r = 5;             // the radius
            this.opacity = 1;       // inital opacity. the dot will fade out
            this.fade = 0.05;       // amount by which to fade on each game tick
            this.remove = false;    // flag for removing this entity. LC.update
                                    // will take care of this

            this.update = function () {
                // reduct the opacity accordingly
                this.opacity -= this.fade;
                // if opacity if 0 or less, flag for removal
                this.remove = (this.opacity < 0) ? true : false;
            };

            this.render = function () {
                LC.Draw.circle(this.x, this.y, this.r, 'rgba(255,0,0,' + this.opacity + ')');
            };

        };

        LC.Bubble = function () {

            this.type = 'bubble';
            this.r = (Math.random() * 20) + 10;
            this.speed = (Math.random() * 3) + 1;

            this.x = (Math.random() * (LC.WIDTH) - this.r);
            this.y = LC.HEIGHT + (Math.random() * 100) + 100;

            // the amount by which the bubble
            // will move from side to side
            this.waveSize = 5 + this.r;
            // we need to remember the original
            // x position for our sine wave calculation
            this.xConstant = this.x;

            this.remove = false;


            this.update = function () {

                // a sine wave is commonly a function of time
                var time = new Date().getTime() * 0.002;

                this.y -= this.speed;
                // the x coord to follow a sine wave
                this.x = this.waveSize * Math.sin(time) + this.xConstant;

                // if offscreen flag for removal
                if (this.y < -10) {
                    LC.score.escaped += 1; // update score
                    this.remove = true;
                }

            };

            this.render = function () {

                LC.Draw.logo(this.x, this.y); 
            };

        };

        LC.Particle = function (x, y, r, col) {

            this.x = x;
            this.y = y;
            this.r = r;
            this.col = col;

            // determines whether particle will
            // travel to the right of left
            // 50% chance of either happening
            this.dir = (Math.random() * 2 > 1) ? 1 : -1;

            // random values so particles do no
            // travel at the same speeds
            this.vx = ~~(Math.random() * 4) * this.dir;
            this.vy = ~~(Math.random() * 7);

            this.remove = false;

            this.update = function () {

                // update coordinates
                this.x += this.vx;
                this.y += this.vy;

                // increase velocity so particle
                // accelerates off screen
                this.vx *= 0.99;
                this.vy *= 0.99;

                // adding this negative amount to the
                // y velocity exerts an upward pull on
                // the particle, as if drawn to the
                // surface
                this.vy -= 0.25;

                // offscreen
                if (this.y < 0) {
                    this.remove = true;
                }

            };


            this.render = function () {
                LC.Draw.circle(this.x, this.y, this.r, this.col);
            };

        };

        window.addEventListener('load', LC.init, false);
        window.addEventListener('resize', LC.resize, false);

    </script>


</body>

</html>